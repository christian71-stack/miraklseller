<?php
/**
 * ProductsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  cbdesk\Mirakl
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Mirakl Marketplace APIs
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest-release
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.17.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace cbdesk\Mirakl\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use cbdesk\Mirakl\ApiException;
use cbdesk\Mirakl\Configuration;
use cbdesk\Mirakl\FormDataProcessor;
use cbdesk\Mirakl\HeaderSelector;
use cbdesk\Mirakl\ObjectSerializer;

/**
 * ProductsApi Class Doc Comment
 *
 * @category Class
 * @package  cbdesk\Mirakl
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'h11' => [
            'application/json',
        ],
        'p31' => [
            'application/json',
        ],
        'p42' => [
            'application/json',
        ],
        'p44' => [
            'application/json',
        ],
        'p45' => [
            'application/json',
        ],
        'p46' => [
            'application/json',
        ],
        'p47' => [
            'application/json',
        ],
        'p51' => [
            'application/json',
        ],
        'pM11' => [
            'application/json',
        ],
        'vL11' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation h11
     *
     * List Catalog categories (parents and children) related to a Catalog category
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Catalog category code (optional)
     * @param  int|null $max_level Number of children catalog category levels to retrieve. If not specified, all child catalog categories are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['h11'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \cbdesk\Mirakl\Model\H11Response200
     */
    public function h11($associative_array)
    {
        list($response) = $this->h11WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation h11WithHttpInfo
     *
     * List Catalog categories (parents and children) related to a Catalog category
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Catalog category code (optional)
     * @param  int|null $max_level Number of children catalog category levels to retrieve. If not specified, all child catalog categories are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['h11'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\Mirakl\Model\H11Response200, HTTP status code, HTTP response headers (array of strings)
     */
    public function h11WithHttpInfo($associative_array)
    {
        $request = $this->h11Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\cbdesk\Mirakl\Model\H11Response200',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\cbdesk\Mirakl\Model\H11Response200',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\Mirakl\Model\H11Response200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation h11Async
     *
     * List Catalog categories (parents and children) related to a Catalog category
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Catalog category code (optional)
     * @param  int|null $max_level Number of children catalog category levels to retrieve. If not specified, all child catalog categories are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['h11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function h11Async($associative_array)
    {
        return $this->h11AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation h11AsyncWithHttpInfo
     *
     * List Catalog categories (parents and children) related to a Catalog category
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Catalog category code (optional)
     * @param  int|null $max_level Number of children catalog category levels to retrieve. If not specified, all child catalog categories are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['h11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function h11AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\cbdesk\Mirakl\Model\H11Response200';
        $request = $this->h11Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'h11'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Catalog category code (optional)
     * @param  int|null $max_level Number of children catalog category levels to retrieve. If not specified, all child catalog categories are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['h11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function h11Request($associative_array)
    {
        // unbox the parameters from the associative array
        $hierarchy = array_key_exists('hierarchy', $associative_array) ? $associative_array['hierarchy'] : null;
        $max_level = array_key_exists('max_level', $associative_array) ? $associative_array['max_level'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['h11'][0];
        




        $resourcePath = '/api/hierarchies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hierarchy,
            'hierarchy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_level,
            'max_level', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p31
     *
     * Get products for a list of product references
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $product_references List of the product&#39;s identifiers with type, &lt;em&gt;(structure: \&quot;&lt;code&gt;product_references&#x3D;&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;,&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;, ...&lt;/code&gt;\&quot;)&lt;/em&gt; where accepted &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; are operator’s product references, like &lt;code&gt;EAN&lt;/code&gt; or &lt;code&gt;UPC&lt;/code&gt; for example. Note that &lt;code&gt;SHOP_SKU&lt;/code&gt; or &lt;code&gt;SKU&lt;/code&gt; are invalid &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; for this API. (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string|null $locale &amp;lt;ISO-639&amp;gt;_&amp;lt;ISO-3166&amp;gt; (\&quot;en_US\&quot;) or &amp;lt;ISO-639&amp;gt; (\&quot;en\&quot;) locale for internationalized data translation. The APIs only accept locales that are equivalent to the languages activated in the back-office. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p31'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \cbdesk\Mirakl\Model\P31Response200
     */
    public function p31($associative_array)
    {
        list($response) = $this->p31WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation p31WithHttpInfo
     *
     * Get products for a list of product references
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $product_references List of the product&#39;s identifiers with type, &lt;em&gt;(structure: \&quot;&lt;code&gt;product_references&#x3D;&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;,&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;, ...&lt;/code&gt;\&quot;)&lt;/em&gt; where accepted &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; are operator’s product references, like &lt;code&gt;EAN&lt;/code&gt; or &lt;code&gt;UPC&lt;/code&gt; for example. Note that &lt;code&gt;SHOP_SKU&lt;/code&gt; or &lt;code&gt;SKU&lt;/code&gt; are invalid &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; for this API. (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string|null $locale &amp;lt;ISO-639&amp;gt;_&amp;lt;ISO-3166&amp;gt; (\&quot;en_US\&quot;) or &amp;lt;ISO-639&amp;gt; (\&quot;en\&quot;) locale for internationalized data translation. The APIs only accept locales that are equivalent to the languages activated in the back-office. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p31'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\Mirakl\Model\P31Response200, HTTP status code, HTTP response headers (array of strings)
     */
    public function p31WithHttpInfo($associative_array)
    {
        $request = $this->p31Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\cbdesk\Mirakl\Model\P31Response200',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\cbdesk\Mirakl\Model\P31Response200',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\Mirakl\Model\P31Response200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation p31Async
     *
     * Get products for a list of product references
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $product_references List of the product&#39;s identifiers with type, &lt;em&gt;(structure: \&quot;&lt;code&gt;product_references&#x3D;&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;,&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;, ...&lt;/code&gt;\&quot;)&lt;/em&gt; where accepted &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; are operator’s product references, like &lt;code&gt;EAN&lt;/code&gt; or &lt;code&gt;UPC&lt;/code&gt; for example. Note that &lt;code&gt;SHOP_SKU&lt;/code&gt; or &lt;code&gt;SKU&lt;/code&gt; are invalid &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; for this API. (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string|null $locale &amp;lt;ISO-639&amp;gt;_&amp;lt;ISO-3166&amp;gt; (\&quot;en_US\&quot;) or &amp;lt;ISO-639&amp;gt; (\&quot;en\&quot;) locale for internationalized data translation. The APIs only accept locales that are equivalent to the languages activated in the back-office. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p31'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p31Async($associative_array)
    {
        return $this->p31AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p31AsyncWithHttpInfo
     *
     * Get products for a list of product references
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $product_references List of the product&#39;s identifiers with type, &lt;em&gt;(structure: \&quot;&lt;code&gt;product_references&#x3D;&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;,&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;, ...&lt;/code&gt;\&quot;)&lt;/em&gt; where accepted &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; are operator’s product references, like &lt;code&gt;EAN&lt;/code&gt; or &lt;code&gt;UPC&lt;/code&gt; for example. Note that &lt;code&gt;SHOP_SKU&lt;/code&gt; or &lt;code&gt;SKU&lt;/code&gt; are invalid &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; for this API. (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string|null $locale &amp;lt;ISO-639&amp;gt;_&amp;lt;ISO-3166&amp;gt; (\&quot;en_US\&quot;) or &amp;lt;ISO-639&amp;gt; (\&quot;en\&quot;) locale for internationalized data translation. The APIs only accept locales that are equivalent to the languages activated in the back-office. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p31'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p31AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\cbdesk\Mirakl\Model\P31Response200';
        $request = $this->p31Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p31'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $product_references List of the product&#39;s identifiers with type, &lt;em&gt;(structure: \&quot;&lt;code&gt;product_references&#x3D;&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;,&amp;lt;productIdType&amp;gt;|&amp;lt;productId&amp;gt;, ...&lt;/code&gt;\&quot;)&lt;/em&gt; where accepted &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; are operator’s product references, like &lt;code&gt;EAN&lt;/code&gt; or &lt;code&gt;UPC&lt;/code&gt; for example. Note that &lt;code&gt;SHOP_SKU&lt;/code&gt; or &lt;code&gt;SKU&lt;/code&gt; are invalid &lt;code&gt;&amp;lt;productIdType&amp;gt;&lt;/code&gt; for this API. (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string|null $locale &amp;lt;ISO-639&amp;gt;_&amp;lt;ISO-3166&amp;gt; (\&quot;en_US\&quot;) or &amp;lt;ISO-639&amp;gt; (\&quot;en\&quot;) locale for internationalized data translation. The APIs only accept locales that are equivalent to the languages activated in the back-office. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p31'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function p31Request($associative_array)
    {
        // unbox the parameters from the associative array
        $product_references = array_key_exists('product_references', $associative_array) ? $associative_array['product_references'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $locale = array_key_exists('locale', $associative_array) ? $associative_array['locale'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['p31'][0];
        




        $resourcePath = '/api/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_references,
            'product_references', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locale,
            'locale', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p42
     *
     * Get the import status for a product import
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p42'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \cbdesk\Mirakl\Model\P42Response200
     */
    public function p42($associative_array)
    {
        list($response) = $this->p42WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation p42WithHttpInfo
     *
     * Get the import status for a product import
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p42'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\Mirakl\Model\P42Response200, HTTP status code, HTTP response headers (array of strings)
     */
    public function p42WithHttpInfo($associative_array)
    {
        $request = $this->p42Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\cbdesk\Mirakl\Model\P42Response200',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\cbdesk\Mirakl\Model\P42Response200',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\Mirakl\Model\P42Response200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation p42Async
     *
     * Get the import status for a product import
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p42'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p42Async($associative_array)
    {
        return $this->p42AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p42AsyncWithHttpInfo
     *
     * Get the import status for a product import
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p42'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p42AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\cbdesk\Mirakl\Model\P42Response200';
        $request = $this->p42Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p42'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p42'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function p42Request($associative_array)
    {
        // unbox the parameters from the associative array
        $import = array_key_exists('import', $associative_array) ? $associative_array['import'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['p42'][0];
        
        // verify the required parameter 'import' is set
        if ($import === null || (is_array($import) && count($import) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import when calling p42'
            );
        }



        $resourcePath = '/api/products/imports/{import}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($import !== null) {
            $resourcePath = str_replace(
                '{' . 'import' . '}',
                ObjectSerializer::toPathValue($import),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p44
     *
     * Get the error report file for a product import (\&quot;Non-integrated products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p44'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function p44($associative_array)
    {
        list($response) = $this->p44WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation p44WithHttpInfo
     *
     * Get the error report file for a product import (\&quot;Non-integrated products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p44'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function p44WithHttpInfo($associative_array)
    {
        $request = $this->p44Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation p44Async
     *
     * Get the error report file for a product import (\&quot;Non-integrated products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p44'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p44Async($associative_array)
    {
        return $this->p44AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p44AsyncWithHttpInfo
     *
     * Get the error report file for a product import (\&quot;Non-integrated products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p44'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p44AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\SplFileObject';
        $request = $this->p44Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p44'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p44'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function p44Request($associative_array)
    {
        // unbox the parameters from the associative array
        $import = array_key_exists('import', $associative_array) ? $associative_array['import'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['p44'][0];
        
        // verify the required parameter 'import' is set
        if ($import === null || (is_array($import) && count($import) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import when calling p44'
            );
        }



        $resourcePath = '/api/products/imports/{import}/error_report';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($import !== null) {
            $resourcePath = str_replace(
                '{' . 'import' . '}',
                ObjectSerializer::toPathValue($import),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p45
     *
     * Get the product integration report file for a product import (\&quot;Added products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p45'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function p45($associative_array)
    {
        list($response) = $this->p45WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation p45WithHttpInfo
     *
     * Get the product integration report file for a product import (\&quot;Added products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p45'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function p45WithHttpInfo($associative_array)
    {
        $request = $this->p45Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation p45Async
     *
     * Get the product integration report file for a product import (\&quot;Added products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p45'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p45Async($associative_array)
    {
        return $this->p45AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p45AsyncWithHttpInfo
     *
     * Get the product integration report file for a product import (\&quot;Added products report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p45'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p45AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\SplFileObject';
        $request = $this->p45Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p45'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p45'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function p45Request($associative_array)
    {
        // unbox the parameters from the associative array
        $import = array_key_exists('import', $associative_array) ? $associative_array['import'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['p45'][0];
        
        // verify the required parameter 'import' is set
        if ($import === null || (is_array($import) && count($import) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import when calling p45'
            );
        }



        $resourcePath = '/api/products/imports/{import}/new_product_report';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($import !== null) {
            $resourcePath = str_replace(
                '{' . 'import' . '}',
                ObjectSerializer::toPathValue($import),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p46
     *
     * Get the transformed file for a product import (\&quot;File in operator format\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p46'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function p46($associative_array)
    {
        list($response) = $this->p46WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation p46WithHttpInfo
     *
     * Get the transformed file for a product import (\&quot;File in operator format\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p46'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function p46WithHttpInfo($associative_array)
    {
        $request = $this->p46Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation p46Async
     *
     * Get the transformed file for a product import (\&quot;File in operator format\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p46'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p46Async($associative_array)
    {
        return $this->p46AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p46AsyncWithHttpInfo
     *
     * Get the transformed file for a product import (\&quot;File in operator format\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p46'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p46AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\SplFileObject';
        $request = $this->p46Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p46'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p46'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function p46Request($associative_array)
    {
        // unbox the parameters from the associative array
        $import = array_key_exists('import', $associative_array) ? $associative_array['import'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['p46'][0];
        
        // verify the required parameter 'import' is set
        if ($import === null || (is_array($import) && count($import) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import when calling p46'
            );
        }



        $resourcePath = '/api/products/imports/{import}/transformed_file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($import !== null) {
            $resourcePath = str_replace(
                '{' . 'import' . '}',
                ObjectSerializer::toPathValue($import),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p47
     *
     * Get the transformation error report file for a product import (\&quot;Source file error report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p47'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function p47($associative_array)
    {
        list($response) = $this->p47WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation p47WithHttpInfo
     *
     * Get the transformation error report file for a product import (\&quot;Source file error report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p47'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function p47WithHttpInfo($associative_array)
    {
        $request = $this->p47Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation p47Async
     *
     * Get the transformation error report file for a product import (\&quot;Source file error report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p47'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p47Async($associative_array)
    {
        return $this->p47AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p47AsyncWithHttpInfo
     *
     * Get the transformation error report file for a product import (\&quot;Source file error report\&quot;)
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p47'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p47AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\SplFileObject';
        $request = $this->p47Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p47'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  int $import Import identifier (required)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p47'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function p47Request($associative_array)
    {
        // unbox the parameters from the associative array
        $import = array_key_exists('import', $associative_array) ? $associative_array['import'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['p47'][0];
        
        // verify the required parameter 'import' is set
        if ($import === null || (is_array($import) && count($import) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $import when calling p47'
            );
        }



        $resourcePath = '/api/products/imports/{import}/transformation_error_report';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($import !== null) {
            $resourcePath = str_replace(
                '{' . 'import' . '}',
                ObjectSerializer::toPathValue($import),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation p51
     *
     * Get information about product import statuses
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  \DateTime|null $last_request_date Return only product imports that have changed since this date (optional)
     * @param  string|null $status Product import status. One of &lt;code&gt;CANCELLED&lt;/code&gt;, &lt;code&gt;WAITING&lt;/code&gt;, &lt;code&gt;RUNNING&lt;/code&gt;, &lt;code&gt;SENT&lt;/code&gt;, &lt;code&gt;COMPLETE&lt;/code&gt;, &lt;code&gt;FAILED&lt;/code&gt; (optional)
     * @param  bool|null $has_transformed_file If &lt;code&gt;true&lt;/code&gt; returns only product import trackings with transformed file (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  int|null $max Maximum number of items returned per page (optional)
     * @param  int|null $offset Index of the first item (among all the results) in the returned page (optional)
     * @param  string|null $sort How the results should be sorted (optional)
     * @param  string|null $order Sort direction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p51'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \cbdesk\Mirakl\Model\P51Response200
     */
    public function p51($associative_array)
    {
        list($response) = $this->p51WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation p51WithHttpInfo
     *
     * Get information about product import statuses
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  \DateTime|null $last_request_date Return only product imports that have changed since this date (optional)
     * @param  string|null $status Product import status. One of &lt;code&gt;CANCELLED&lt;/code&gt;, &lt;code&gt;WAITING&lt;/code&gt;, &lt;code&gt;RUNNING&lt;/code&gt;, &lt;code&gt;SENT&lt;/code&gt;, &lt;code&gt;COMPLETE&lt;/code&gt;, &lt;code&gt;FAILED&lt;/code&gt; (optional)
     * @param  bool|null $has_transformed_file If &lt;code&gt;true&lt;/code&gt; returns only product import trackings with transformed file (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  int|null $max Maximum number of items returned per page (optional)
     * @param  int|null $offset Index of the first item (among all the results) in the returned page (optional)
     * @param  string|null $sort How the results should be sorted (optional)
     * @param  string|null $order Sort direction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p51'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\Mirakl\Model\P51Response200, HTTP status code, HTTP response headers (array of strings)
     */
    public function p51WithHttpInfo($associative_array)
    {
        $request = $this->p51Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\cbdesk\Mirakl\Model\P51Response200',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\cbdesk\Mirakl\Model\P51Response200',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\Mirakl\Model\P51Response200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation p51Async
     *
     * Get information about product import statuses
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  \DateTime|null $last_request_date Return only product imports that have changed since this date (optional)
     * @param  string|null $status Product import status. One of &lt;code&gt;CANCELLED&lt;/code&gt;, &lt;code&gt;WAITING&lt;/code&gt;, &lt;code&gt;RUNNING&lt;/code&gt;, &lt;code&gt;SENT&lt;/code&gt;, &lt;code&gt;COMPLETE&lt;/code&gt;, &lt;code&gt;FAILED&lt;/code&gt; (optional)
     * @param  bool|null $has_transformed_file If &lt;code&gt;true&lt;/code&gt; returns only product import trackings with transformed file (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  int|null $max Maximum number of items returned per page (optional)
     * @param  int|null $offset Index of the first item (among all the results) in the returned page (optional)
     * @param  string|null $sort How the results should be sorted (optional)
     * @param  string|null $order Sort direction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p51'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p51Async($associative_array)
    {
        return $this->p51AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation p51AsyncWithHttpInfo
     *
     * Get information about product import statuses
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  \DateTime|null $last_request_date Return only product imports that have changed since this date (optional)
     * @param  string|null $status Product import status. One of &lt;code&gt;CANCELLED&lt;/code&gt;, &lt;code&gt;WAITING&lt;/code&gt;, &lt;code&gt;RUNNING&lt;/code&gt;, &lt;code&gt;SENT&lt;/code&gt;, &lt;code&gt;COMPLETE&lt;/code&gt;, &lt;code&gt;FAILED&lt;/code&gt; (optional)
     * @param  bool|null $has_transformed_file If &lt;code&gt;true&lt;/code&gt; returns only product import trackings with transformed file (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  int|null $max Maximum number of items returned per page (optional)
     * @param  int|null $offset Index of the first item (among all the results) in the returned page (optional)
     * @param  string|null $sort How the results should be sorted (optional)
     * @param  string|null $order Sort direction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p51'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function p51AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\cbdesk\Mirakl\Model\P51Response200';
        $request = $this->p51Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'p51'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  \DateTime|null $last_request_date Return only product imports that have changed since this date (optional)
     * @param  string|null $status Product import status. One of &lt;code&gt;CANCELLED&lt;/code&gt;, &lt;code&gt;WAITING&lt;/code&gt;, &lt;code&gt;RUNNING&lt;/code&gt;, &lt;code&gt;SENT&lt;/code&gt;, &lt;code&gt;COMPLETE&lt;/code&gt;, &lt;code&gt;FAILED&lt;/code&gt; (optional)
     * @param  bool|null $has_transformed_file If &lt;code&gt;true&lt;/code&gt; returns only product import trackings with transformed file (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  int|null $max Maximum number of items returned per page (optional)
     * @param  int|null $offset Index of the first item (among all the results) in the returned page (optional)
     * @param  string|null $sort How the results should be sorted (optional)
     * @param  string|null $order Sort direction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['p51'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function p51Request($associative_array)
    {
        // unbox the parameters from the associative array
        $last_request_date = array_key_exists('last_request_date', $associative_array) ? $associative_array['last_request_date'] : null;
        $status = array_key_exists('status', $associative_array) ? $associative_array['status'] : null;
        $has_transformed_file = array_key_exists('has_transformed_file', $associative_array) ? $associative_array['has_transformed_file'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $max = array_key_exists('max', $associative_array) ? $associative_array['max'] : null;
        $offset = array_key_exists('offset', $associative_array) ? $associative_array['offset'] : null;
        $sort = array_key_exists('sort', $associative_array) ? $associative_array['sort'] : null;
        $order = array_key_exists('order', $associative_array) ? $associative_array['order'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['p51'][0];
        









        $resourcePath = '/api/products/imports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_request_date,
            'last_request_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_transformed_file,
            'has_transformed_file', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pM11
     *
     * Get the product attribute configuration
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Code of the hierarchy (category) for which to retrieve the attributes. If not specified, all attributes are retrieved. (optional)
     * @param  int|null $max_level Number of children hierarchy (category) levels to retrieve. If not specified, attributes from all children hierarchies are retrieved. (optional)
     * @param  bool|null $all_operator_attributes Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get all the operator attributes. (optional, default to false)
     * @param  bool|null $with_roles Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get only the attributes that have roles. (optional, default to false)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pM11'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \cbdesk\Mirakl\Model\PM11Response200
     */
    public function pM11($associative_array)
    {
        list($response) = $this->pM11WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation pM11WithHttpInfo
     *
     * Get the product attribute configuration
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Code of the hierarchy (category) for which to retrieve the attributes. If not specified, all attributes are retrieved. (optional)
     * @param  int|null $max_level Number of children hierarchy (category) levels to retrieve. If not specified, attributes from all children hierarchies are retrieved. (optional)
     * @param  bool|null $all_operator_attributes Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get all the operator attributes. (optional, default to false)
     * @param  bool|null $with_roles Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get only the attributes that have roles. (optional, default to false)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pM11'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\Mirakl\Model\PM11Response200, HTTP status code, HTTP response headers (array of strings)
     */
    public function pM11WithHttpInfo($associative_array)
    {
        $request = $this->pM11Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\cbdesk\Mirakl\Model\PM11Response200',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\cbdesk\Mirakl\Model\PM11Response200',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\Mirakl\Model\PM11Response200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation pM11Async
     *
     * Get the product attribute configuration
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Code of the hierarchy (category) for which to retrieve the attributes. If not specified, all attributes are retrieved. (optional)
     * @param  int|null $max_level Number of children hierarchy (category) levels to retrieve. If not specified, attributes from all children hierarchies are retrieved. (optional)
     * @param  bool|null $all_operator_attributes Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get all the operator attributes. (optional, default to false)
     * @param  bool|null $with_roles Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get only the attributes that have roles. (optional, default to false)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pM11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pM11Async($associative_array)
    {
        return $this->pM11AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pM11AsyncWithHttpInfo
     *
     * Get the product attribute configuration
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Code of the hierarchy (category) for which to retrieve the attributes. If not specified, all attributes are retrieved. (optional)
     * @param  int|null $max_level Number of children hierarchy (category) levels to retrieve. If not specified, attributes from all children hierarchies are retrieved. (optional)
     * @param  bool|null $all_operator_attributes Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get all the operator attributes. (optional, default to false)
     * @param  bool|null $with_roles Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get only the attributes that have roles. (optional, default to false)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pM11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pM11AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\cbdesk\Mirakl\Model\PM11Response200';
        $request = $this->pM11Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pM11'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $hierarchy Code of the hierarchy (category) for which to retrieve the attributes. If not specified, all attributes are retrieved. (optional)
     * @param  int|null $max_level Number of children hierarchy (category) levels to retrieve. If not specified, attributes from all children hierarchies are retrieved. (optional)
     * @param  bool|null $all_operator_attributes Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get all the operator attributes. (optional, default to false)
     * @param  bool|null $with_roles Set to \&quot;&lt;code&gt;true&lt;/code&gt;\&quot; to get only the attributes that have roles. (optional, default to false)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pM11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pM11Request($associative_array)
    {
        // unbox the parameters from the associative array
        $hierarchy = array_key_exists('hierarchy', $associative_array) ? $associative_array['hierarchy'] : null;
        $max_level = array_key_exists('max_level', $associative_array) ? $associative_array['max_level'] : null;
        $all_operator_attributes = array_key_exists('all_operator_attributes', $associative_array) ? $associative_array['all_operator_attributes'] : false;
        $with_roles = array_key_exists('with_roles', $associative_array) ? $associative_array['with_roles'] : false;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['pM11'][0];
        






        $resourcePath = '/api/products/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hierarchy,
            'hierarchy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_level,
            'max_level', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $all_operator_attributes,
            'all_operator_attributes', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_roles,
            'with_roles', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/csv', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vL11
     *
     * Get information about operator&#39;s value lists
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $code The operator&#39;s values list code. If not specified, all values lists are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vL11'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \cbdesk\Mirakl\Model\VL11Response200
     */
    public function vL11($associative_array)
    {
        list($response) = $this->vL11WithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation vL11WithHttpInfo
     *
     * Get information about operator&#39;s value lists
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $code The operator&#39;s values list code. If not specified, all values lists are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vL11'] to see the possible values for this operation
     *
     * @throws \cbdesk\Mirakl\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\Mirakl\Model\VL11Response200, HTTP status code, HTTP response headers (array of strings)
     */
    public function vL11WithHttpInfo($associative_array)
    {
        $request = $this->vL11Request($associative_array);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\cbdesk\Mirakl\Model\VL11Response200',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\cbdesk\Mirakl\Model\VL11Response200',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\Mirakl\Model\VL11Response200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vL11Async
     *
     * Get information about operator&#39;s value lists
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $code The operator&#39;s values list code. If not specified, all values lists are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vL11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vL11Async($associative_array)
    {
        return $this->vL11AsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vL11AsyncWithHttpInfo
     *
     * Get information about operator&#39;s value lists
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $code The operator&#39;s values list code. If not specified, all values lists are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vL11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vL11AsyncWithHttpInfo($associative_array)
    {
        $returnType = '\cbdesk\Mirakl\Model\VL11Response200';
        $request = $this->vL11Request($associative_array);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vL11'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string|null $code The operator&#39;s values list code. If not specified, all values lists are retrieved (optional)
     * @param  int|null $shop_id Use this parameter when your user has access to several shops. If not specified, the shop_id from your default shop will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vL11'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vL11Request($associative_array)
    {
        // unbox the parameters from the associative array
        $code = array_key_exists('code', $associative_array) ? $associative_array['code'] : null;
        $shop_id = array_key_exists('shop_id', $associative_array) ? $associative_array['shop_id'] : null;
        $contentType = $associative_array['contentType'] ?? self::contentTypes['vL11'][0];
        



        $resourcePath = '/api/values_lists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop_id,
            'shop_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
